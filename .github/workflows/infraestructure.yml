name: Infrastructure Pipeline

on:
  push:
    branches: [ "master", "dev" ]
    paths:
      - "infra/**"
      - "docker-compose.yml"
      - "docker-compose.prod.yml"
  pull_request:
    branches: [ "master", "dev" ]
    paths:
      - "infra/**"
  workflow_dispatch:

env:
  TF_VERSION: '1.5.0'
  AZURE_REGION: 'East US'

jobs:
  validate:
    name: Validate Infrastructure Code
    runs-on: ubuntu-latest
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Azure CLI Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Terraform Format Check
        working-directory: ./infrastructure
        run: terraform fmt -check -recursive
      
      - name: Terraform Init
        working-directory: ./infrastructure
        run: |
          terraform init \
            -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=microservice-app.tfstate"
      
      - name: Terraform Validate
        working-directory: ./infrastructure
        run: terraform validate
      
      - name: Terraform Security Scan
        uses: aquasecurity/tfsec-action@v1.0.0
        with:
          working_directory: infrastructure
      
      - name: Validate Docker Compose
        run: |
          docker-compose config
          docker-compose -f docker-compose.prod.yml config

  plan:
    name: Plan Infrastructure Changes
    runs-on: ubuntu-latest
    needs: validate
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Azure CLI Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Terraform Plan
        working-directory: ./infrastructure
        run: |
          terraform init \
            -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=microservice-app.tfstate"
          terraform plan -out=tfplan -var-file="environments/dev.tfvars"
      
      - name: Comment PR with Plan
        uses: actions/github-script@v7
        with:
          script: |
            const output = `#### Terraform Plan ðŸ“– \`${{ github.event_name }}\`
            
            <details><summary>Show Plan</summary>
            
            \`\`\`terraform
            Plan will be shown here after running terraform show
            \`\`\`
            
            </details>
            
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`, Workflow: \`${{ github.workflow }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            })

  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: validate
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    environment: production
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Azure CLI Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Terraform Apply
        working-directory: ./infrastructure
        run: |
          terraform init \
            -backend-config="storage_account_name=${{ secrets.TERRAFORM_STORAGE_ACCOUNT }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=microservice-app.tfstate"
          terraform apply -auto-approve -var-file="environments/prod.tfvars"
      
      - name: Get Terraform Outputs
        working-directory: ./infrastructure
        run: |
          echo "VM_IP=$(terraform output -raw vm_public_ip)" >> $GITHUB_ENV
          echo "RESOURCE_GROUP=$(terraform output -raw resource_group_name)" >> $GITHUB_ENV
          terraform output -json > outputs.json
      
      - name: Upload Terraform Outputs
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs
          path: infrastructure/outputs.json
      
      - name: Update GitHub Secrets with Infrastructure Info
        run: |
          # Actualizar VM_IP_KEY con la nueva IP si cambiÃ³
          echo "Infrastructure deployed successfully"
          echo "VM IP: ${{ env.VM_IP }}"

  configure-vm:
    name: Configure VM and Deploy Services
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: infrastructure/
      
      - name: Extract VM IP from Terraform outputs
        run: |
          VM_IP=$(jq -r '.vm_public_ip.value' infrastructure/outputs.json)
          echo "VM_IP=$VM_IP" >> $GITHUB_ENV
      
      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass
      
      - name: Wait for VM to be ready
        run: |
          echo "Waiting for VM to be accessible..."
          for i in {1..30}; do
            if sshpass -p "${{ secrets.VM_PASSWORD_KEY }}" ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no azureuser@${{ env.VM_IP }} "echo 'VM is ready'"; then
              echo "VM is accessible"
              break
            fi
            echo "Attempt $i failed, waiting 10 seconds..."
            sleep 10
          done
      
      - name: Setup Docker and Dependencies on VM
        run: |
          sshpass -p "${{ secrets.VM_PASSWORD_KEY }}" ssh -o StrictHostKeyChecking=no azureuser@${{ env.VM_IP }} "
            # Actualizar sistema
            sudo apt-get update
            
            # Instalar Docker si no estÃ¡ instalado
            if ! command -v docker &> /dev/null; then
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker azureuser
            fi
            
            # Instalar Docker Compose si no estÃ¡ instalado
            if ! command -v docker-compose &> /dev/null; then
              sudo curl -L \"https://github.com/docker/compose/releases/download/v2.20.2/docker-compose-\$(uname -s)-\$(uname -m)\" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
            
            # Crear directorio para la aplicaciÃ³n
            sudo mkdir -p /opt/microservice-app-example
            sudo chown azureuser:azureuser /opt/microservice-app-example
          "
      
      - name: Deploy Application to VM
        run: |
          sshpass -p "${{ secrets.VM_PASSWORD_KEY }}" ssh -o StrictHostKeyChecking=no azureuser@${{ env.VM_IP }} "
            cd /opt/microservice-app-example
            
            # Clonar o actualizar repositorio
            if [ ! -d .git ]; then
              git clone https://github.com/bortizf/microservice-app-example.git .
            else
              git pull origin master
            fi
            
            # Construir y levantar servicios
            docker-compose -f docker-compose.prod.yml build
            docker-compose -f docker-compose.prod.yml up -d
            
            # Verificar que los servicios estÃ©n corriendo
            docker-compose -f docker-compose.prod.yml ps
          "

  test-infrastructure:
    name: Test Infrastructure and Services
    runs-on: ubuntu-latest
    needs: configure-vm
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4
      
      - name: Download Terraform Outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs
          path: infrastructure/
      
      - name: Extract Infrastructure Info
        run: |
          VM_IP=$(jq -r '.vm_public_ip.value' infrastructure/outputs.json)
          echo "VM_IP=$VM_IP" >> $GITHUB_ENV
      
      - name: Test Infrastructure Connectivity
        run: |
          chmod +x scripts/test-infrastructure.sh
          ./scripts/test-infrastructure.sh ${{ env.VM_IP }}
      
      - name: Health Check All Services
        run: |
          chmod +x scripts/health-check.sh
          ./scripts/health-check.sh ${{ env.VM_IP }}